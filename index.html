<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bilbane Simulator</title>
    <!-- Last inn Tailwind CSS for enkel styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Last inn Inter font fra Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c; /* M√∏rk bakgrunn */
            color: #e2e8f0; /* Lys tekst */
            overflow: hidden; /* Forhindre rulling */
        }
        canvas {
            background-color: #2d3748; /* Bane bakgrunn */
            border: 4px solid #4a5568; /* Ramme rundt banen */
            border-radius: 12px;
            touch-action: none; /* Forbedre ber√∏ringsinteraksjon */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 90vw; /* Responsive bredde */
            max-height: 80vh; /* Responsive h√∏yde */
            width: auto;
            height: auto;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px;
        }
        h1 {
            margin-bottom: 20px;
            font-size: 2.5rem; /* St√∏rre tittel for mobile enheter */
            text-align: center;
            color: #a0aec0;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap; /* Kontroller p√• flere linjer om n√∏dvendig */
        }
        .control-button {
            background-color: #4a5568;
            color: #e2e8f0;
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            min-width: 80px; /* Minimum bredde for knapper */
        }
        .control-button:hover {
            background-color: #6a748a;
            transform: translateY(-2px);
        }
        .control-button:active {
            transform: translateY(0);
            background-color: #5a6375;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bilbane Simulator üèéÔ∏è</h1>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <button id="upButton" class="control-button">‚ñ≤ Opp</button>
            <button id="leftButton" class="control-button">‚óÄ Venstre</button>
            <button id="rightButton" class="control-button">‚ñ∂ H√∏yre</button>
            <button id="downButton" class="control-button">‚ñº Ned</button>
        </div>
    </div>

    <script>
        // Hent canvas-elementet og dets 2D-renderingskontekst
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Sett opp canvas-dimensjoner for responsivitet
        function resizeCanvas() {
            canvas.width = Math.min(window.innerWidth * 0.9, 900); // Litt st√∏rre maksbredde
            canvas.height = Math.min(window.innerHeight * 0.8, 700); // Litt st√∏rre maksh√∏yde
            initializeTrackPoints(); // Kall for √• oppdatere banepunktene
            draw(); // Tegn p√• nytt etter st√∏rrelsesendring
        }

        window.addEventListener('resize', resizeCanvas);

        // Bane definisjon (en mer kompleks bane som en serie punkter)
        let trackPoints = [];

        function initializeTrackPoints() {
            // Definer banepunkter basert p√• den nye canvas-st√∏rrelsen
            const cw = canvas.width;
            const ch = canvas.height;
            const padding = 50; // Polstring fra kanten

            trackPoints = [
                { x: padding, y: padding + 50 },
                { x: cw - padding - 50, y: padding },
                { x: cw - padding, y: ch / 2 },
                { x: cw - padding - 50, y: ch - padding },
                { x: padding + 50, y: ch - padding },
                { x: padding, y: ch / 2 },
                { x: padding + 50, y: padding } // Tilbake til start for en l√∏kke
            ];

            // Oppdater bilens startposisjon
            car.x = trackPoints[0].x;
            car.y = trackPoints[0].y;
            car.pathIndex = 0;
            updateCarDirection();
        }

        // Bilobjekt
        const car = {
            x: 0, // Initialisert i initializeTrackPoints
            y: 0, // Initialisert i initializeTrackPoints
            width: 20,
            height: 40,
            color: '#ef4444', // R√∏d bil
            speed: 3,
            rotation: 0, // Rotasjon i radianer
            pathIndex: 0 // Hvilket punkt p√• banen bilen er p√• vei mot
        };

        // Tegn banen
        function drawTrack() {
            ctx.beginPath();
            ctx.moveTo(trackPoints[0].x, trackPoints[0].y);
            for (let i = 1; i < trackPoints.length; i++) {
                ctx.lineTo(trackPoints[i].x, trackPoints[i].y);
            }
            // Koble det siste punktet til det f√∏rste for en lukket bane
            ctx.lineTo(trackPoints[0].x, trackPoints[0].y);

            ctx.lineWidth = 40; // Bredde p√• banen
            ctx.strokeStyle = '#6366f1'; // Bl√• bane
            ctx.lineJoin = 'round'; // Glatte hj√∏rner
            ctx.stroke();

            // Midtlinje p√• banen
            ctx.beginPath();
            ctx.moveTo(trackPoints[0].x, trackPoints[0].y);
            for (let i = 1; i < trackPoints.length; i++) {
                ctx.lineTo(trackPoints[i].x, trackPoints[i].y);
            }
            ctx.lineTo(trackPoints[0].x, trackPoints[0].y); // Lukk midtlinjen
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#fde047'; // Gul midtlinje
            ctx.setLineDash([10, 10]); // Stiplet linje
            ctx.stroke();
            ctx.setLineDash([]); // Tilbakestill linjestilen
        }

        // Tegn bilen
        function drawCar() {
            ctx.save(); // Lagre gjeldende transformasjonstilstand
            ctx.translate(car.x, car.y); // Flytt lerretets origo til bilens posisjon
            ctx.rotate(car.rotation); // Roter lerretet med bilens rotasjon
            ctx.fillStyle = car.color;
            ctx.fillRect(-car.width / 2, -car.height / 2, car.width, car.height); // Tegn bilen sentrert
            ctx.restore(); // Gjenopprett den lagrede transformasjonstilstanden
        }

        // Oppdater bilens posisjon
        function updateCar() {
            const targetPoint = trackPoints[car.pathIndex];

            // Beregn avstand til m√•lpunktet
            const dx = targetPoint.x - car.x;
            const dy = targetPoint.y - car.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < car.speed) {
                // Hvis bilen er n√¶r m√•lpunktet, flytt til neste punkt
                car.x = targetPoint.x;
                car.y = targetPoint.y;
                car.pathIndex = (car.pathIndex + 1) % trackPoints.length; // G√• til neste punkt
                updateCarDirection(); // Oppdater retning for neste segment
            } else {
                // Flytt bilen mot m√•lpunktet
                car.x += (dx / distance) * car.speed;
                car.y += (dy / distance) * car.speed;
            }
        }

        // Oppdater bilens rotasjon basert p√• retningen til neste punkt
        function updateCarDirection() {
            const currentPoint = trackPoints[car.pathIndex];
            const nextPoint = trackPoints[(car.pathIndex + 1) % trackPoints.length];

            const dx = nextPoint.x - currentPoint.x;
            const dy = nextPoint.y - currentPoint.y;

            // Beregn vinkelen i radianer
            // Juster med Math.PI / 2 for √• kompensere for at bilen tegnes vertikalt
            car.rotation = Math.atan2(dy, dx) + Math.PI / 2;
        }

        // Funksjon for √• tegne alt
        function draw() {
            // T√∏m lerretet
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#2d3748'; // Fyll bakgrunnen for √• sikre at den er fullstendig t√∏mt
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawTrack();
            drawCar();
        }

        // Spill√∏kke
        function gameLoop() {
            updateCar();
            draw();
            requestAnimationFrame(gameLoop); // Kj√∏rer loop kontinuerlig
        }

        // Initialiser canvas og start spill√∏kken ved lasting
        resizeCanvas(); // Kall for √• sette initial st√∏rrelse og initialisere trackPoints
        gameLoop();

        // Implementer kontroller for mobil
        let currentDirection = '';

        function moveCar(direction) {
            currentDirection = direction;
            if (direction === 'up') {
                car.speed = 5;
            } else if (direction === 'down') {
                car.speed = 1;
            }
        }

        function stopCar() {
            currentDirection = '';
            car.speed = 3; // Tilbakestill hastighet
        }

        // Hendelselyttere for knapper (touch og click)
        const upButton = document.getElementById('upButton');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const downButton = document.getElementById('downButton');

        upButton.addEventListener('mousedown', () => moveCar('up'));
        upButton.addEventListener('touchstart', (e) => { e.preventDefault(); moveCar('up'); });
        upButton.addEventListener('mouseup', stopCar);
        upButton.addEventListener('touchend', stopCar);

        leftButton.addEventListener('mousedown', () => { car.rotation -= 0.1; });
        leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); car.rotation -= 0.1; });
        leftButton.addEventListener('touchmove', (e) => { e.preventDefault(); car.rotation -= 0.05; }); // Kontinuerlig svinging

        rightButton.addEventListener('mousedown', () => { car.rotation += 0.1; });
        rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); car.rotation += 0.1; });
        rightButton.addEventListener('touchmove', (e) => { e.preventDefault(); car.rotation += 0.05; }); // Kontinuerlig svinging

        downButton.addEventListener('mousedown', () => moveCar('down'));
        downButton.addEventListener('touchstart', (e) => { e.preventDefault(); moveCar('down'); });
        downButton.addEventListener('mouseup', stopCar);
        downButton.addEventListener('touchend', stopCar);

        // Tastaturkontroller for skrivebord (valgfritt, men nyttig for testing)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') {
                moveCar('up');
            } else if (e.key === 'ArrowDown') {
                moveCar('down');
            } else if (e.key === 'ArrowLeft') {
                car.rotation -= 0.1;
            } else if (e.key === 'ArrowRight') {
                car.rotation += 0.1;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                stopCar();
            }
        });
    </script>
</body>
</html>
